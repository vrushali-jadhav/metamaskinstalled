{"ast":null,"code":"'use strict'; // Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\n\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\n\nfunction getMostUsed(indents) {\n  let result = 0;\n  let maxUsed = 0;\n  let maxWeight = 0;\n\n  for (const [key, [usedCount, weight]] of indents) {\n    if (usedCount > maxUsed || usedCount === maxUsed && weight > maxWeight) {\n      maxUsed = usedCount;\n      maxWeight = weight;\n      result = key;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = string => {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  } // Remember the size of previous line's indentation\n\n\n  let previousSize = 0;\n  let previousIndentType; // Indents key (ident type + size of the indents/unindents)\n\n  let key; // Remember how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n  // The key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n  //\n  // indents = {\n  //    t3: [1, 0],\n  //    t4: [1, 5],\n  //    s5: [1, 0],\n  //   s12: [1, 0],\n  // }\n\n  const indents = new Map();\n\n  for (const line of string.split(/\\n/g)) {\n    if (!line) {\n      // Ignore empty lines\n      continue;\n    }\n\n    let indent;\n    let indentType;\n    let weight;\n    let entry;\n    const matches = line.match(INDENT_REGEX);\n\n    if (matches === null) {\n      previousSize = 0;\n      previousIndentType = '';\n    } else {\n      indent = matches[0].length;\n\n      if (matches[1]) {\n        indentType = 's';\n      } else {\n        indentType = 't';\n      }\n\n      if (indentType !== previousIndentType) {\n        previousSize = 0;\n      }\n\n      previousIndentType = indentType;\n      weight = 0;\n      const indentDifference = indent - previousSize;\n      previousSize = indent; // Previous line have same indent?\n\n      if (indentDifference === 0) {\n        weight++; // We use the key from previous loop\n      } else {\n        key = indentType + String(indentDifference > 0 ? indentDifference : -indentDifference);\n      } // Update the stats\n\n\n      entry = indents.get(key);\n\n      if (entry === undefined) {\n        entry = [1, 0]; // Init\n      } else {\n        entry = [++entry[0], entry[1] + weight];\n      }\n\n      indents.set(key, entry);\n    }\n  }\n\n  const result = getMostUsed(indents);\n  let amount = 0;\n  let type;\n  let indent = '';\n\n  if (result !== 0) {\n    amount = Number(result.slice(1));\n\n    if (result[0] === 's') {\n      type = 'space';\n      indent = ' '.repeat(amount);\n    } else {\n      type = 'tab';\n      indent = '\\t'.repeat(amount);\n    }\n  }\n\n  return {\n    amount,\n    type,\n    indent\n  };\n};","map":{"version":3,"sources":["/Users/vrushalij/Desktop/Blockchain/HarshUpdated/evoting-react-auth/Frontend/node_modules/detect-indent/index.js"],"names":["INDENT_REGEX","getMostUsed","indents","result","maxUsed","maxWeight","key","usedCount","weight","module","exports","string","TypeError","previousSize","previousIndentType","Map","line","split","indent","indentType","entry","matches","match","length","indentDifference","String","get","undefined","set","amount","type","Number","slice","repeat"],"mappings":"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","sourcesContent":["'use strict';\n\n// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\n\nfunction getMostUsed(indents) {\n\tlet result = 0;\n\tlet maxUsed = 0;\n\tlet maxWeight = 0;\n\n\tfor (const [key, [usedCount, weight]] of indents) {\n\t\tif (usedCount > maxUsed || (usedCount === maxUsed && weight > maxWeight)) {\n\t\t\tmaxUsed = usedCount;\n\t\t\tmaxWeight = weight;\n\t\t\tresult = key;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Remember the size of previous line's indentation\n\tlet previousSize = 0;\n\tlet previousIndentType;\n\n\t// Indents key (ident type + size of the indents/unindents)\n\tlet key;\n\n\t// Remember how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\t// The key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\t//\n\t// indents = {\n\t//    t3: [1, 0],\n\t//    t4: [1, 5],\n\t//    s5: [1, 0],\n\t//   s12: [1, 0],\n\t// }\n\tconst indents = new Map();\n\n\tfor (const line of string.split(/\\n/g)) {\n\t\tif (!line) {\n\t\t\t// Ignore empty lines\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet indent;\n\t\tlet indentType;\n\t\tlet weight;\n\t\tlet entry;\n\t\tconst matches = line.match(INDENT_REGEX);\n\n\t\tif (matches === null) {\n\t\t\tpreviousSize = 0;\n\t\t\tpreviousIndentType = '';\n\t\t} else {\n\t\t\tindent = matches[0].length;\n\n\t\t\tif (matches[1]) {\n\t\t\t\tindentType = 's';\n\t\t\t} else {\n\t\t\t\tindentType = 't';\n\t\t\t}\n\n\t\t\tif (indentType !== previousIndentType) {\n\t\t\t\tpreviousSize = 0;\n\t\t\t}\n\n\t\t\tpreviousIndentType = indentType;\n\n\t\t\tweight = 0;\n\n\t\t\tconst indentDifference = indent - previousSize;\n\t\t\tpreviousSize = indent;\n\n\t\t\t// Previous line have same indent?\n\t\t\tif (indentDifference === 0) {\n\t\t\t\tweight++;\n\t\t\t\t// We use the key from previous loop\n\t\t\t} else {\n\t\t\t\tkey = indentType + String(indentDifference > 0 ? indentDifference : -indentDifference);\n\t\t\t}\n\n\t\t\t// Update the stats\n\t\t\tentry = indents.get(key);\n\n\t\t\tif (entry === undefined) {\n\t\t\t\tentry = [1, 0]; // Init\n\t\t\t} else {\n\t\t\t\tentry = [++entry[0], entry[1] + weight];\n\t\t\t}\n\n\t\t\tindents.set(key, entry);\n\t\t}\n\t}\n\n\tconst result = getMostUsed(indents);\n\n\tlet amount = 0;\n\tlet type;\n\tlet indent = '';\n\n\tif (result !== 0) {\n\t\tamount = Number(result.slice(1));\n\n\t\tif (result[0] === 's') {\n\t\t\ttype = 'space';\n\t\t\tindent = ' '.repeat(amount);\n\t\t} else {\n\t\t\ttype = 'tab';\n\t\t\tindent = '\\t'.repeat(amount);\n\t\t}\n\t}\n\n\treturn {\n\t\tamount,\n\t\ttype,\n\t\tindent\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}