{"ast":null,"code":"var net = require('net'),\n    crypto = require('crypto'),\n    format = require('util').format,\n    fs = require('fs');\n\nvar nl = '\\r\\n';\n/**\n * Create a new GNTP request of the given `type`.\n *\n * @param {String} type either NOTIFY or REGISTER\n * @api private\n */\n\nfunction GNTP(type, opts) {\n  opts = opts || {};\n  this.type = type;\n  this.host = opts.host || 'localhost';\n  this.port = opts.port || 23053;\n  this.request = 'GNTP/1.0 ' + type + ' NONE' + nl;\n  this.resources = [];\n  this.attempts = 0;\n  this.maxAttempts = 5;\n}\n/**\n * Build a response object from the given `resp` response string.\n *\n * The response object has a key/value pair for every header in the response, and \n * a `.state` property equal to either OK, ERROR, or CALLBACK.\n *\n * An example GNTP response:\n *\n *     GNTP/1.0 -OK NONE\\r\\n\n *     Response-Action: REGISTER\\r\\n\n *     \\r\\n\n *\n *  Which would parse to:\n *      \n *      { state: 'OK', 'Response-Action': 'REGISTER' }\n *\n * @param {String} resp\n * @return {Object}\n * @api private\n */\n\n\nGNTP.prototype.parseResp = function (resp) {\n  var parsed = {},\n      head,\n      body;\n  resp = resp.slice(0, resp.indexOf(nl + nl)).split(nl);\n  head = resp[0];\n  body = resp.slice(1);\n  parsed.state = head.match(/-(OK|ERROR|CALLBACK)/)[0].slice(1);\n  body.forEach(function (ln) {\n    ln = ln.split(': ');\n    parsed[ln[0]] = ln[1];\n  });\n  return parsed;\n};\n/**\n * Call `GNTP.send()` with the given arguments after a certain delay.\n *\n * @api private\n */\n\n\nGNTP.prototype.retry = function () {\n  var self = this,\n      args = arguments;\n  setTimeout(function () {\n    self.send.apply(self, args);\n  }, 750);\n};\n/**\n * Add a resource to the GNTP request.\n *\n * @param {Buffer} file\n * @return {String}\n * @api private\n */\n\n\nGNTP.prototype.addResource = function (file) {\n  var id = crypto.createHash('md5').update(file).digest('hex'),\n      header = 'Identifier: ' + id + nl + 'Length: ' + file.length + nl + nl;\n  this.resources.push({\n    header: header,\n    file: file\n  });\n  return 'x-growl-resource://' + id;\n};\n/**\n * Append another header `name` with a value of `val` to the request. If `val` is\n * undefined, the header will be left out.\n *\n * @param {String} name\n * @param {String} val\n * @api public\n */\n\n\nGNTP.prototype.add = function (name, val) {\n  if (val === undefined) return;\n  /* Handle icon files when they're image paths or Buffers. */\n\n  if (/-Icon/.test(name) && !/^https?:\\/\\//.test(val)) {\n    if (/\\.(png|gif|jpe?g)$/.test(val)) val = this.addResource(fs.readFileSync(val));else if (val instanceof Buffer) val = this.addResource(val);\n  }\n\n  this.request += name + ': ' + val + nl;\n};\n/**\n * Append a newline to the request.\n *\n * @api public\n */\n\n\nGNTP.prototype.newline = function () {\n  this.request += nl;\n};\n/**\n * Send the GNTP request, calling `callback` after successfully sending the \n * request.\n *\n * An example GNTP request:\n *\n *     GNTP/1.0 REGISTER NONE\\r\\n\n *     Application-Name: Growly.js\\r\\n\n *     Notifications-Count: 1\\r\\n\n *     \\r\\n\n *     Notification-Name: default\\r\\n\n *     Notification-Display-Name: Default Notification\\r\\n\n *     Notification-Enabled: True\\r\\n\n *     \\r\\n\n * \n * @param {Function} callback which will be passed the parsed response\n * @api public\n */\n\n\nGNTP.prototype.send = function (callback) {\n  var self = this,\n      socket = net.connect(this.port, this.host),\n      resp = '';\n\n  callback = callback || function () {};\n\n  this.attempts += 1;\n  socket.on('connect', function () {\n    socket.write(self.request);\n    self.resources.forEach(function (res) {\n      socket.write(res.header);\n      socket.write(res.file);\n      socket.write(nl + nl);\n    });\n  });\n  socket.on('data', function (data) {\n    resp += data.toString();\n    /* Wait until we have a complete response which is signaled by two CRLF's. */\n\n    if (resp.slice(resp.length - 4) !== nl + nl) return;\n    resp = self.parseResp(resp);\n    /* We have to manually close the connection for certain responses; otherwise,\n       reset `resp` to prepare for the next response chunk.  */\n\n    if (resp.state === 'ERROR' || resp.state === 'CALLBACK') socket.end();else resp = '';\n  });\n  socket.on('end', function () {\n    /* Retry on 200 (timed out), 401 (unknown app), or 402 (unknown notification). */\n    if (['200', '401', '402'].indexOf(resp['Error-Code']) >= 0) {\n      if (self.attempts <= self.maxAttempts) {\n        self.retry(callback);\n      } else {\n        var msg = 'GNTP request to \"%s:%d\" failed with error code %s (%s)';\n        callback(new Error(format(msg, self.host, self.port, resp['Error-Code'], resp['Error-Description'])));\n      }\n    } else {\n      callback(undefined, resp);\n    }\n  });\n  socket.on('error', function () {\n    callback(new Error(format('Error while sending GNTP request to \"%s:%d\"', self.host, self.port)));\n    socket.destroy();\n  });\n};\n\nmodule.exports = GNTP;","map":{"version":3,"sources":["/Users/vrushalij/Desktop/Submission/css_updated/Frontend/node_modules/growly/lib/gntp.js"],"names":["net","require","crypto","format","fs","nl","GNTP","type","opts","host","port","request","resources","attempts","maxAttempts","prototype","parseResp","resp","parsed","head","body","slice","indexOf","split","state","match","forEach","ln","retry","self","args","arguments","setTimeout","send","apply","addResource","file","id","createHash","update","digest","header","length","push","add","name","val","undefined","test","readFileSync","Buffer","newline","callback","socket","connect","on","write","res","data","toString","end","msg","Error","destroy","module","exports"],"mappings":"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","sourcesContent":["var net = require('net'),\n    crypto = require('crypto'),\n    format = require('util').format,\n    fs = require('fs');\n\nvar nl = '\\r\\n';\n\n/**\n * Create a new GNTP request of the given `type`.\n *\n * @param {String} type either NOTIFY or REGISTER\n * @api private\n */\n\nfunction GNTP(type, opts) {\n    opts = opts || {};\n    this.type = type;\n    this.host = opts.host || 'localhost';\n    this.port = opts.port || 23053;\n    this.request = 'GNTP/1.0 ' + type + ' NONE' + nl;\n    this.resources = [];\n    this.attempts = 0;\n    this.maxAttempts = 5;\n}\n\n/**\n * Build a response object from the given `resp` response string.\n *\n * The response object has a key/value pair for every header in the response, and \n * a `.state` property equal to either OK, ERROR, or CALLBACK.\n *\n * An example GNTP response:\n *\n *     GNTP/1.0 -OK NONE\\r\\n\n *     Response-Action: REGISTER\\r\\n\n *     \\r\\n\n *\n *  Which would parse to:\n *      \n *      { state: 'OK', 'Response-Action': 'REGISTER' }\n *\n * @param {String} resp\n * @return {Object}\n * @api private\n */\n\nGNTP.prototype.parseResp = function(resp) {\n    var parsed = {}, head, body;\n    resp = resp.slice(0, resp.indexOf(nl + nl)).split(nl);\n    head = resp[0];\n    body = resp.slice(1);\n\n    parsed.state = head.match(/-(OK|ERROR|CALLBACK)/)[0].slice(1);\n    body.forEach(function(ln) {\n        ln = ln.split(': ');\n        parsed[ln[0]] = ln[1];\n    });\n\n    return parsed;\n};\n\n/**\n * Call `GNTP.send()` with the given arguments after a certain delay.\n *\n * @api private\n */\n\nGNTP.prototype.retry = function() {\n    var self = this, \n        args = arguments;\n    setTimeout(function() {\n        self.send.apply(self, args);\n    }, 750);\n};\n\n\n/**\n * Add a resource to the GNTP request.\n *\n * @param {Buffer} file\n * @return {String}\n * @api private\n */\n\nGNTP.prototype.addResource = function(file) {\n    var id = crypto.createHash('md5').update(file).digest('hex'),\n        header = 'Identifier: ' + id + nl + 'Length: ' + file.length + nl + nl;\n    this.resources.push({ header: header, file: file });\n    return 'x-growl-resource://' + id;\n};\n\n/**\n * Append another header `name` with a value of `val` to the request. If `val` is\n * undefined, the header will be left out.\n *\n * @param {String} name\n * @param {String} val\n * @api public\n */\n\nGNTP.prototype.add = function(name, val) {\n    if (val === undefined) \n        return;\n\n    /* Handle icon files when they're image paths or Buffers. */\n    if (/-Icon/.test(name) && !/^https?:\\/\\//.test(val) ) {\n        if (/\\.(png|gif|jpe?g)$/.test(val))\n            val = this.addResource(fs.readFileSync(val));\n        else if (val instanceof Buffer)\n            val = this.addResource(val);\n    }\n\n    this.request += name + ': ' + val + nl;\n};\n\n/**\n * Append a newline to the request.\n *\n * @api public\n */\n\nGNTP.prototype.newline = function() {\n    this.request += nl;\n};\n\n/**\n * Send the GNTP request, calling `callback` after successfully sending the \n * request.\n *\n * An example GNTP request:\n *\n *     GNTP/1.0 REGISTER NONE\\r\\n\n *     Application-Name: Growly.js\\r\\n\n *     Notifications-Count: 1\\r\\n\n *     \\r\\n\n *     Notification-Name: default\\r\\n\n *     Notification-Display-Name: Default Notification\\r\\n\n *     Notification-Enabled: True\\r\\n\n *     \\r\\n\n * \n * @param {Function} callback which will be passed the parsed response\n * @api public\n */\n\nGNTP.prototype.send = function(callback) {\n    var self = this,\n        socket = net.connect(this.port, this.host),\n        resp = '';\n\n    callback = callback || function() {};\n\n    this.attempts += 1;\n\n    socket.on('connect', function() {\n        socket.write(self.request);\n\n        self.resources.forEach(function(res) {\n            socket.write(res.header);\n            socket.write(res.file);\n            socket.write(nl + nl);\n        });\n    });\n\n    socket.on('data', function(data) {\n        resp += data.toString();\n\n        /* Wait until we have a complete response which is signaled by two CRLF's. */\n        if (resp.slice(resp.length - 4) !== (nl + nl)) return; \n\n        resp = self.parseResp(resp); \n\n        /* We have to manually close the connection for certain responses; otherwise,\n           reset `resp` to prepare for the next response chunk.  */\n        if (resp.state === 'ERROR' || resp.state === 'CALLBACK')\n            socket.end();\n        else\n            resp = '';\n    });\n\n    socket.on('end', function() {\n        /* Retry on 200 (timed out), 401 (unknown app), or 402 (unknown notification). */\n        if (['200', '401', '402'].indexOf(resp['Error-Code']) >= 0) {\n            if (self.attempts <= self.maxAttempts) {\n                self.retry(callback);\n            } else {\n                var msg = 'GNTP request to \"%s:%d\" failed with error code %s (%s)';\n                callback(new Error(format(msg, self.host, self.port, resp['Error-Code'], resp['Error-Description'])));\n            }\n        } else {\n            callback(undefined, resp);\n        }\n    });\n\n    socket.on('error', function() {\n        callback(new Error(format('Error while sending GNTP request to \"%s:%d\"', self.host, self.port)));\n        socket.destroy();\n    });\n};\n\nmodule.exports = GNTP;\n"]},"metadata":{},"sourceType":"script"}